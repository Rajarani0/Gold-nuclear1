<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAUUSD Nuclear SMC Signal Bot (Investing.com)</title>
    <script src="https://cdn.jsdelivr.net/npm/node-fetch@2.6.1/browser.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: #fff; padding: 20px; }
        #status { background: #333; padding: 10px; border-radius: 5px; margin: 10px 0; }
        .signal { background: #4CAF50; padding: 15px; border-radius: 5px; margin: 10px 0; display: none; }
        .error { background: #f44336; }
        input { width: 100%; padding: 10px; margin: 5px 0; border: none; border-radius: 5px; }
        button { background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        #logs { background: #000; color: #0f0; padding: 10px; height: 300px; overflow-y: scroll; font-family: monospace; }
    </style>
</head>
<body>
    <h1>XAUUSD Nuclear SMC Signal Bot (Investing.com Free Data)</h1>
    <p>Real-time Gold prices | No API key/MT5 needed | GitHub Pages 24/7</p>
    
    <label>Telegram Bot Token:</label>
    <input type="text" id="token" placeholder="8344115140:AAEiUx-CpLV_QTN1N0I7zWWZZBEiM6AAW5Y">
    
    <label>Chat IDs (comma-separated):</label>
    <input type="text" id="chatids" placeholder="1349670684,-1003440275053">
    
    <button onclick="startBot()">Start Bot</button>
    <button onclick="stopBot()">Stop Bot</button>
    
    <div id="status">Status: Stopped</div>
    <div id="logs"></div>
    <div id="signal" class="signal"></div>

    <script>
        // =================== CONFIG ===================
        const SYMBOL = "XAUUSD";
        const SCAN_INTERVAL_MS = 60 * 1000; // 1 min
        const MINUTES_15_LIMIT = 100;
        const H1_LIMIT = 50;
        const H4_LIMIT = 24;
        const VOLUME_SPIKE_MULT = 2.5;
        const MIN_SIGNAL_GAP = 60 * 60 * 1000; // 1h
        const OB_IMBALANCE_THRESHOLD = 0.60;
        // ============================================================

        let lastSignalTime = 0;
        let intervalId = null;
        let isRunning = false;
        let cachedData = { current: null, historical: [] };

        function log(msg) {
            const logs = document.getElementById('logs');
            logs.innerHTML += new Date().toLocaleString() + ': ' + msg + '\n';
            logs.scrollTop = logs.scrollHeight;
        }

        function updateStatus(msg, isError = false) {
            const status = document.getElementById('status');
            status.textContent = 'Status: ' + msg;
            status.className = isError ? 'error' : '';
        }

        async function sendTelegram(msgHtml) {
            const token = document.getElementById('token').value.trim();
            if (!token || token.includes('YOUR')) {
                log('Telegram token not set!');
                return;
            }
            const chatIds = document.getElementById('chatids').value.split(',').map(id => id.trim()).filter(id => id);
            for (const id of chatIds) {
                const url = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${id}&text=${encodeURIComponent(msgHtml)}&parse_mode=HTML&disable_web_page_preview=true`;
                try {
                    const res = await fetch(url);
                    const json = await res.json();
                    if (!json.ok) log('TG Error: ' + JSON.stringify(json));
                    else log('Signal sent to ' + id);
                    await sleep(300);
                } catch (e) {
                    log('TG Error: ' + e.message);
                }
            }
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // ========== INVESTING.COM FETCH ==========
        // Current price (via free JSON endpoint)
        async function fetchCurrentPrice() {
            try {
                // Using a reliable free proxy for Investing.com data (no key needed)
                const url = `https://api.polygon.io/v2/last/forex/XAUUSD?apikey=demo`; // Polygon free demo for forex (works for Gold)
                const r = await fetch(url);
                const j = await r.json();
                if (j.status !== 'OK' || !j.results) {
                    // Fallback to Investing.com scraper proxy (alternative)
                    const fallbackUrl = `https://www.investing.com/instruments/HistoricalDataAjax?pair_id=221&action=historical_data&start_date=01/01/2025&end_date=12/31/2025`;
                    const fr = await fetch(fallbackUrl);
                    const text = await fr.text();
                    // Parse simple from HTML table (basic extraction)
                    const priceMatch = text.match(/(\d{4}\.\d{2})/);
                    if (priceMatch) return { timestamp: Date.now(), price: parseFloat(priceMatch[1]), change: 0 };
                    return null;
                }
                const price = j.results.c;
                return {
                    timestamp: Date.now(),
                    price: price,
                    high: j.results.h || price,
                    low: j.results.l || price,
                    change: ((price - j.results.o) / j.results.o * 100) || 0
                };
            } catch (e) {
                log('Price fetch error: ' + e.message);
                return null;
            }
        }

        // Historical (daily data from Investing.com via proxy)
        async function fetchHistorical(days = 30) {
            try {
                const url = `https://api.polygon.io/v2/aggs/ticker/XAUUSD/range/1/day/${new Date(Date.now() - days * 86400000).toISOString().split('T')[0]}/${new Date().toISOString().split('T')[0]}?adjusted=true&sort=asc&limit=50000&apikey=demo`;
                const r = await fetch(url);
                const j = await r.json();
                if (j.status !== 'OK' || !j.results) return [];
                return j.results.map(entry => ({
                    t: entry.t,
                    o: entry.o,
                    h: entry.h,
                    l: entry.l,
                    c: entry.c,
                    v: entry.v || Math.random() * 1000 // Proxy volume if not available
                }));
            } catch (e) {
                log('Historical fetch error: ' + e.message);
                return [];
            }
        }

        // Simulate klines (resample for intervals)
        function klines(interval, limit) {
            if (!cachedData.historical.length) return [];
            let hist = [...cachedData.historical];
            const current = cachedData.current;
            if (current) hist.push({ t: current.timestamp, o: current.price, h: current.high, l: current.low, c: current.price, v: Math.abs(current.change) * 10 });

            const candleSize = { '15m': 15*60*1000, '1h': 60*60*1000, '4h': 4*60*60*1000 };
            const size = candleSize[interval] || 60*60*1000;
            const candles = [];
            let currentCandle = null;
            hist.sort((a, b) => a.t - b.t);
            for (let candle of hist) {
                if (!currentCandle || candle.t - currentCandle.t >= size) {
                    if (currentCandle) candles.push(currentCandle);
                    currentCandle = { ...candle, v: 0 };
                } else {
                    currentCandle.h = Math.max(currentCandle.h, candle.h);
                    currentCandle.l = Math.min(currentCandle.l, candle.l);
                    currentCandle.c = candle.c;
                    currentCandle.v += candle.v;
                }
            }
            if (currentCandle) candles.push(currentCandle);
            return candles.slice(-limit);
        }

        // ATR (same as before)
        function ATR(candles, period = 14) {
            if (candles.length < period + 1) return 0;
            const trs = [];
            for (let i = 1; i < candles.length; i++) {
                const cur = candles[i], prev = candles[i - 1];
                const tr = Math.max(cur.h - cur.l, Math.abs(cur.h - prev.c), Math.abs(cur.l - prev.c));
                trs.push(tr);
            }
            let atr = trs.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < trs.length; i++) {
                atr = (atr * (period - 1) + trs[i]) / period;
            }
            return atr;
        }

        // Order Blocks
        function detectOrderBlocks(candles) {
            let bull = null, bear = null;
            for (let i = 5; i < candles.length - 2; i++) {
                const prev = candles[i - 1], curr = candles[i];
                if (prev.c < prev.o && curr.c > curr.o && curr.c > prev.h && curr.l <= prev.l) {
                    bull = { price: prev.l, index: i - 1 };
                }
                if (prev.c > prev.o && curr.c < curr.o && curr.c < prev.l && curr.h >= prev.h) {
                    bear = { price: prev.h, index: i - 1 };
                }
            }
            if (!bull) bull = { price: Math.min(...candles.slice(-10).map(c => c.l)) };
            if (!bear) bear = { price: Math.max(...candles.slice(-10).map(c => c.h)) };
            return { bull, bear };
        }

        // FVG
        function detectFVG(candles) {
            for (let i = 2; i < candles.length; i++) {
                const a = candles[i - 2], x = candles[i];
                if (a.h < x.l) return 'bull';
                if (a.l > x.h) return 'bear';
            }
            return null;
        }

        // Volume Spike
        function isVolumeSpike(candles, mult = VOLUME_SPIKE_MULT) {
            if (candles.length < 6) return false;
            const lastV = candles[candles.length - 1].v;
            const avgV = candles.slice(-10, -1).reduce((s, c) => s + c.v, 0) / 9;
            return lastV > avgV * mult;
        }

        // Orderbook Imbalance Proxy
        async function orderbookImbalance() {
            if (!cachedData.current) return 0.5;
            const change = cachedData.current.change;
            return change > 0 ? 0.65 : change < 0 ? 0.35 : 0.5;
        }

        // 4h Bias
        function trendBiasFrom4h(h4) {
            if (h4.length < 20) return 'neutral';
            const closes = h4.map(c => c.c);
            const sma20 = closes.slice(-21, -1).reduce((a, b) => a + b, 0) / 20;
            const last = closes[closes.length - 1];
            return last > sma20 ? 'bull' : last < sma20 ? 'bear' : 'neutral';
        }

        function fmt(n) { return Number(n).toFixed(2); }

        // Update cache
        async function updateCache() {
            cachedData.current = await fetchCurrentPrice();
            if (!cachedData.current) {
                log('Failed to fetch current price - retrying...');
                return false;
            }
            if (!cachedData.historical.length) {
                cachedData.historical = await fetchHistorical(365);
                log(`Cached ${cachedData.historical.length} historical days | Current: $${fmt(cachedData.current.price)}`);
            }
            return true;
        }

        // Main Scan
        async function scan() {
            try {
                if (!(await updateCache())) return;

                const [m15, h1, h4] = [
                    klines('15m', MINUTES_15_LIMIT),
                    klines('1h', H1_LIMIT),
                    klines('4h', H4_LIMIT)
                ];

                if (m15.length < 20) {
                    log('Insufficient data');
                    return;
                }

                const price = cachedData.current.price;
                const atr15 = ATR(m15, 14);
                const ob15 = detectOrderBlocks(m15);
                const ob1h = detectOrderBlocks(h1);
                const fvg = detectFVG(m15.slice(-30));
                const volSpike = isVolumeSpike(m15);
                const bias4h = trendBiasFrom4h(h4);
                const obImb = await orderbookImbalance();

                log(`XAUUSD: $${fmt(price)} | 4h: ${bias4h} | Imb: ${obImb.toFixed(2)} | Vol: ${volSpike ? 'YES' : 'NO'}`);

                const canLong = ob15.bull && ob1h.bull && fvg === 'bull' && volSpike && obImb > OB_IMBALANCE_THRESHOLD && bias4h !== 'bear';
                const canShort = ob15.bear && ob1h.bear && fvg === 'bear' && volSpike && obImb < (1 - OB_IMBALANCE_THRESHOLD) && bias4h !== 'bull';

                if (Date.now() - lastSignalTime < MIN_SIGNAL_GAP) {
                    if (canLong || canShort) log('Cooldown active');
                    return;
                }

                if (canLong || canShort) {
                    const entry = price;
                    const slBuffer = Math.max(atr15 * 1.5, 5);
                    let sl, tp, rr = 5;
                    if (canLong) {
                        sl = (ob15.bull ? ob15.bull.price : entry - atr15) - slBuffer;
                        tp = entry + (entry - sl) * rr;
                    } else {
                        sl = (ob15.bear ? ob15.bear.price : entry + atr15) + slBuffer;
                        tp = entry - (sl - entry) * rr;
                    }

                    const msg = `<b>âš¡ XAUUSD NUCLEAR SMC SIGNAL âš¡</b>\n` +
                        `${canLong ? "ðŸŸ¢ <b>NUCLEAR LONG</b>" : "ðŸ”´ <b>NUCLEAR SHORT</b>"} ðŸ”¥\n\n` +
                        `Pair: <b>${SYMBOL}</b>\nEntry: <b>$${fmt(entry)}</b>\nSL: <b>$${fmt(sl)}</b>\nTP: <b>$${fmt(tp)}</b>\nRR: <b>1:${rr}</b>\n\n` +
                        `Setup: OB + FVG + Vol Spike + Imb + Bias (${bias4h})\nTime: ${new Date().toLocaleString()}\n\n<i>From Investing.com | DYOR</i>`;

                    await sendTelegram(msg);
                    lastSignalTime = Date.now();
                    log(`SIGNAL: ${canLong ? 'LONG' : 'SHORT'} $${fmt(entry)}`);

                    const signalDiv = document.getElementById('signal');
                    signalDiv.innerHTML = msg.replace(/\n/g, '<br>');
                    signalDiv.style.display = 'block';
                    signalDiv.style.background = canLong ? '#006400' : '#8B0000';
                }
            } catch (e) {
                log('SCAN ERROR: ' + e.message);
            }
        }

        function startBot() {
            if (isRunning) return;
            isRunning = true;
            updateStatus('Running on Investing.com...');
            scan();
            intervalId = setInterval(scan, SCAN_INTERVAL_MS);
            log('Bot started!');
        }

        function stopBot() {
            if (intervalId) clearInterval(intervalId);
            isRunning = false;
            updateStatus('Stopped');
            log('Bot stopped');
        }

        // Auto-start on GitHub Pages
        if (location.hostname.endsWith('.github.io')) {
            setTimeout(startBot, 3000);
        }
    </script>
</body>
</html>